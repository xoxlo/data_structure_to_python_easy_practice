# CHAPTER 9 탐색트리

- 탐색트리 : 탐색을 위한 트리 기반의 자료구조
- 이진탐색트리(BST) : 효율적인 탐색을 위한 이진트리 기반의 자료구조
- 이진탐색트리의 조건 -> 왼쪽 서브트리 노드의 키값 < 루트 노드의 키값 < 오른쪽 서브트리 노드의 키값
- 모든 노드는 유일한 키를 갖는다
----------------------------------------------------------------------------------------------------
## 순차탐색
- 시간복잡도 O(n)

## 이진탐색
- 시간복잡도 O(log_2n)

## 해싱
- 시간복잡도 O(1)
----------------------------------------------------------------------------------------------------
# 이진 탐색 트리 : 노드 구조
- 차이점 : 노드의 데이터는 하나의 엔트리, 즉 ( 탐색키, 키에 대한 값 ) 형태

----------------------------------------------------------------------------------------------------
## 삭제 연산
- CASE1 : 단말 노드의 삭제
    - 삭제할 노드의 부모 노드의 링크를 변경. left -> None or right -> None

- CASE2 : 자식이 하나인 노드의 삭제
    - 자신 대신에 유일한 자식을 부모 노드에 연결

- CASE3 : 두 개의 자식을 모두 갖는 노드의 삭제
    - 후계자 노드의 선택 : 왼쪽 서브트리의 가장 큰 노드 or 오른쪽 서브트리의 가장 작은 노드
    - 삭제 위치에 놓더라도 항상 왼쪽 서브트리보다는 크고 오른쪽 서브트리보다는 작은 조건을 만족시킬 수 있음
----------------------------------------------------------------------------------------------------
## 예상문제

### 이진탐색트리의 정의를 쓰고 조건을 쓰시오.
    이진탐색트리는 효율적인 탐색을 위한 이진트리 기반의 자료구조이다.
    왼쪽 서브트리 노드의 키값이 루트 노드의 키값보다 작고 오른쪽 서브트리 노드의 키값이 루트 노드의 키값보다 커야 한다.
----------------------------------------------------------------------------------------------------
### 해싱의 장, 단점을 쓰시오.
    장점은 탐색을 위한 가장 빠른 방법이다.
    단점은 메모리를 많이 사용하고 오버플로 문제를 해결해야 한다.
----------------------------------------------------------------------------------------------------
### 이진탐색트리의 장, 단점을 쓰시오.
    장점은 데이터 검색 속도가 빠르다. 일반적으로 시간복잡도는 O(log2n)
    단점은 최악의 경우 경사이진트리와 같이 한 쪽으로만 치우쳐 있을 경우 시간복잡도가 O(n)이 된다.
    이진탐색트리의 효율을 높이기 위해서는 가능한 한 트리가 좌우료 균형 잡혀있어야 한다.
----------------------------------------------------------------------------------------------------
### 이진탐색트리의 삭제 연산 코드 문제
    빈칸 채우기
    소스 내용 이해하기 어떤 알고리즘으로 돌아가는지
    소스를 주고 case1인지 case2인지 case3인지 맞추는 문제 일수도?
    case3가 나올 가능성이 제일 큼 ( 어려워서 )
    부모 노드의 링크가 수정되어야 한다는 것 유의

    case1은 단말 노드의 삭제
        자식노드가 없어서 제일 간단.
        삭제할 노드의 부모 링크를 None으로 수정 ( 그럼 부모가 없어지면서 자동으로 사라짐 )
    case2는 자식이 하나인 노드의 삭제
        삭제할 노드의 유일한 자식을 삭제할 노드의 부모 노드에 연결
        부모 노드의 자식으로 들어가는 것
    case3는 두 개의 자식을 모두 갖는 노드의 삭제
        삭제가 좀 더 간편한 후계자 노드(부모 노드와 가까운 노드 권장)
        후계자 선정은 삭제할 노드의 왼쪽 서브 트리의 제일 큰값이나 오른쪽 서브 트리의 제일 작은 값을 가진 노드로 한다.
        삭제 위치에 놓이더라도 항상 왼쪽 서브 트리보다는 크고 오른쪽 서브 트리보다는 작은 조건으 만족하기 때문에
----------------------------------------------------------------------------------------------------
### AVL트리 - 균형이진탐색트리
    왼쪽 서브트리의 높이와 오른쪽 서브트리의 높이 차가 1이 넘지 않는 이진탐색트리이다.
----------------------------------------------------------------------------------------------------
### AVL트리의 특징을 쓰시오.
    균형인수는 왼쪽 서브트리의 높이와 오른쪽 서브트리의 높이 차
    AVL트리의 균형이 깨졌을 때는 회전을 통해서 AVL트리를 만족하게 한다.
    RR, LL, RL, LR회전이 있다.
----------------------------------------------------------------------------------------------------
### 아래 리스트를 이용해 AVL트리를 만드시오.
    이게 제일 복잡? 어렵?
    단순하게 나오면 개쉬운데 자식들이 여러개 있으면 헷갈림
    RR회전은 균형이 깨진 노드를 기준으로 오른쪽으로 두번 내려간다고 생각
        그 후 균형이 깨진 노드 다음(밑으로)을 왼쪽으로 회전하면서 위로 올림
        자식이 많은 노드는 알아서 잘 이동
    LL회전은 균형이 깨진 노드를 기준으로 왼쪽으로 두번 내려간다고 생각
        그 후 균형이 깨진 노드 다음(밑으로)을 오른쪽으로 회전하면서 위로 올림
        자식이 많은 노드는 알아서 잘 이동
    RL회전은 균형이 깨진 노드 기준으로 위로 오->왼
        그 후 제일 밑 노드를 LL회전(우회전)하고 그 다음 RR회전(좌회전)
    LR회전은 균형이 깨진 노드 기준으로 위로 왼->오
        그 후 제일 밑 노드를 RR회전(좌회전)하고 그 다음 LL회전(우회전)
        
    시발 이거 헷갈려서 2시간 헤맸다 줘가튼거
----------------------------------------------------------------------------------------------------