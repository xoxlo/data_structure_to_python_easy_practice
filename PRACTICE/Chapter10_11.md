# CHAPTER 10 , 11 | 그래프 , 가중치 그래프

## 기본용어
    인접 정점 : 간선에 의해 직접 연결된 정점
    정점의 차수 : 정점에 연결된 간선의 수
    경로 : 경로는 다양하게 존재
    경로의 길이 : 경로를 구성하는데 사용된 간선의 수
    단순 경로 : 경로 중에 반복 되는 간선이 없음
    싸이클 : 시작 정점과 종료 정점이 같음
    연결 그래프 : 모든 정점들 사이에 경로가 존재, 그 반대면 비연결 그래프
    트리 : 사이클을 가지지 않는 연결 그래프
    완전 그래프 : 모든 정점 간에 간선이 존재 -> 이 그래프의 간선의 수는 ' n(n-1)/2 '

단어 그대로인 용어가 많기 때문에 각 용어와 뜻을 연결시키면 이해하기 쉬움
----------------------------------------------------------------------------------------------------
## 예상문제 ?
    그래프는 가장 일반화된 자료구조, 연결된 객체들 사이의 관계를 표현, 정점들 사이에는 순서가 없다.
----------------------------------------------------------------------------------------------------
### 그래프의 종류와 각 그래프 특징을 쓰시오.
    그래프 종류 : 무방향 그래프, 방향 그래프, 가중치 그래프
    무방향 그래프 -> 간선에 방향이 표시되지 않음
    방향 그래프 -> 간선에 방향성이 존재
    가중치 그래프 -> 간선에 비용이나 가중치가 할당되어 있음
    부분 그래프 -> 그래프 G가 있다면 그래프 G의 부분 집합으로 이루어진 그래프
----------------------------------------------------------------------------------------------------
### 오일로 경로의 정의를 쓰시오.
    그래프에 존재하는 모든 간선을 한번만 통과하면서 처음 정점으로 되돌아오는 경로
    간선의 개수가 짝수일 때만 오일러 경로 존재
----------------------------------------------------------------------------------------------------
### 그래프의 표현방법과 차이를 쓰시오.
    그래프의 표현 방법 : 인접행렬, 인접리스트
    인접행렬 - n^2개의 메모리 공간 필요, 정점의 비해 간선의 수가 매우 많은 조밀 그래프에서 효과적
            모든 간선의 수 ? O(n^2)
    인접리스트 - n+2e개의 메모리 공간 필요, 정점에 비해 간선의 수가 매우 적은 희소 그래프에서 효과적
            모든 간선의 수 ? O(n+e)
----------------------------------------------------------------------------------------------------
### 인접행렬에서 무방향 그래프와 방향 그래프의 차이점을 쓰시오.
    무방향 그래프는 대칭 행렬, 상위 삼각이나 하위 삼각만 저장하여 메모리를 절약할 수 있음
    방향 그래프는 대칭 행렬이 아님
----------------------------------------------------------------------------------------------------
### 인접리스트의 표현방법을 쓰시오.
    리스트(인덱스 이용), 딕셔너리(정점의 이름 -> key, 정점의 인접 리스트(정점) -> value), 집합, 튜플
----------------------------------------------------------------------------------------------------
### 그래프의 탐색 방법과 특징을 쓰시오.
    깊이우선탐색 DFS(depth first search) -> 한 방향으로 갈 수 있을 때까지 계속 탐색 | 스택, 순환 구조
                                        인접행렬 : O(n^2), 인접리스트 : O(n+e)
    너비우선탐색 BFS(breadth first search) -> 시작 정점으로 부터 가까운 정점을 먼저 방문 | 큐, 반복 구조
                                        인접행렬 : O(n^2), 인접리스트 : O(n+e)
희소 그래프면 인접리스트로 표현하는게 효과적
----------------------------------------------------------------------------------------------------
### 신장트리는 무엇인가?
    그래프 내의 모든 정점을 포함하는 트리이다.
----------------------------------------------------------------------------------------------------
### 신장트리가 되기 위한 조건을 쓰시오.
    1. 모든 정점은 연결되어 있어야함
    2. 간선의 수는 n-1개이다 (여기서 n은 정점의 수)
    3. 싸이클이 없어야함
----------------------------------------------------------------------------------------------------
### 깊이우선탐색과 너비우선탐색을 했을 때 방문하게 되는 순서를 쓰시오
    A - B - D - E
    |   |    \ | 
    C - F - G  H
    깊이우선탐색
    A -> B -> D -> E -> H -> C -> F -> G
    너비우선탐색
    A -> B -> C -> D -> F -> E -> H -> G
----------------------------------------------------------------------------------------------------
### 위상 정렬 과정을 그림으로 쓰시오.
    정점들의 선행 순서를 위배하지 않으면서 모든 정점을 나열하는 것
    방향 그래프에 사이클이 존재하지 않아야함
    위상정렬은 한 그래프에 여러가지가 존재함
    
    진입차수가 0인 정점부터 삭제하는 과정이다
    하나 삭제가 될 때마다 진입차수를 재기록 해야한다
----------------------------------------------------------------------------------------------------
### 그래프와 가중치 그래프의 차이점을 설명하시오.
    그래프는 정점간의 간선이 연결 되어있으면 1로 표현, 하지만 가중치 그래프는 가중치 값으로 표현
    또한 그래프는 연결된 간선이 없을 때 0으로 표현, 가중치 그래프는 무한대로 표현
----------------------------------------------------------------------------------------------------
### 가중치 그래프만의 특징
    가중치 그래프의 인접 행렬의 대각선 성분은 0으로 표현하거나 None으로 표현한다
    자체 간선을 허용하는 그래프라면 자체 간선의 가중치 저장
    자신 -> 자신
    최소신장트리 -> 대각선 성분은 None
    최단경로거리 -> 대각선 성분은 0
----------------------------------------------------------------------------------------------------
### 최소비용 신장 트리의 응요분야를 쓰시오.
    통신망, 도로망, 배관 작업, 전기 회로
----------------------------------------------------------------------------------------------------
### 최소비용 신장 트리가 되기 위한 조건과 표현방법을 쓰시오.
    - MST : minimum spanning tree -> 여러 가능한 신장 트리들 중에서 사용된 간선들의 가중치 합이 최소인 신장 트리
    그래프의 모든 정점들은 연결되어야 함
    간선의 가중치 합(비용)이 최소
    사이클X
    간선의 수가 n-1개

    Kruskal알고리즘, Prim알고리즘
----------------------------------------------------------------------------------------------------
### Kruskal의 MST 알고리즘을 이용하여 2가지 표현 방법으로 나타내시오.
    - 표현방법 1
    오름차순
    사이클 X

    - 표현방법 2
    내림차순
    분리X -> 하나라도 연결이 되어있어야함
----------------------------------------------------------------------------------------------------
### Kruskal의 MST 알고리즘 특징을 쓰시오.
    간선들이 가중치에 따라 정렬이 되어있어야함
    탐욕적인 기법을 사용
    그 순간에 최적이라고 생각되는 것을 선택하는 방법
    하지만 궁긍적으로 최적이라는 보장은 없음
----------------------------------------------------------------------------------------------------
### Prim의 MST 알고리즘의 특징을 쓰시오.
    간선들을 정렬을 안하고 바로 임의의 정점에서 시작
    가장 유리해 보이는 정점을 탐욕적으로 선택 -> 연결된 간선들 중에서 제일 가중치가 적은 정점 선택 ( 반복 )
----------------------------------------------------------------------------------------------------    
### Prim의 알고리즘과 Kruskal의 알고리즘의 차이점을 쓰시오.
    Prim의 알고리즘의 시간복잡도는 O(n^2)이고 Kruskal의 알고리즘의 시간복잡도는 O(elog2e)이다.

    희소 그래프를 대상 -> Kruskal 적합
    완전 그래프를 대상 -> Prim 적합

    희소그래프는 정점에 비해 간선이 적은 그래프
    완전그래프는 정점에 비해 간선이 많은 그래프
----------------------------------------------------------------------------------------------------
### 최단 경로 특징과 알고리즘의 차이점을 쓰시오
    여러 경로들 중에서 간선들의 가중치 합이 최소가 되는 경로
    대각선 성분은 모두 0으로 처리
    
    Dijkstra의 최단 경로 알고리즘 -> O(n^2)
        - 하나의 정점 -> 모든 정점
    Floyd의 최단 경로 알고리즘 -> O(n^3)
        - 모든 정점 -> 모든 정점

간선의 가중치는 반드시 양수, 가중치로 음수는 허용 하지 않음
----------------------------------------------------------------------------------------------------
### 아래 그래프에서 Dijkstra의 알고리즘을 이용하여 dist의 리스트를 차례대로 나열 하여라.
    Dijkstra알고리즘은 크게 시작 정점 v와 임의의 집합 S와 dist배열이 저장되있는 리스트가 있다.
    S에 포함되지 않은 정점들 중 가장 가까운 정점을 선택해서 최단거리를 dist에 저장하고 S에 그 정점을 추가한다.
    이 행동을 계속 반복한다.
    그러면 dist에는 A에서부터 모든 정점으로부터 최단 경로의 거리가 저장된다.
----------------------------------------------------------------------------------------------------
### 아래 소스코드는 Floyd 알고리즘 일부이다. 빈 칸에 들어갈 코드를 적으시오.
    for i in range(vsize): 
        for j in range(vsize):
            if( A[i][k] + A[k][j] < A[i][j] ):      ----> A행렬이 k를 거치는 경로가 더 짧으면
                A[i][j] = A[i][k] + A[k][j]         ----> A[i][j] 갱신
----------------------------------------------------------------------------------------------------
### Floyd 알고리즘 최단 경로 소스 일부 ( 빈 칸 채우기 )
    A^k[i][j]=min(A^k-1[i][j], A^k-1[i][k]+A^k-1[k][j])

    i->j까지 가는 최단 경로 = min(지금까지 알고있던 경로 , k를 거쳐서 가는 경로)
    여기서 제일 최단 경로가 i->j에 갱신됨
----------------------------------------------------------------------------------------------------
### 아래 소스코드는 Dijkstra 알고리즘 일부이다. 빈 칸에 들어갈 코드를 적으시오.
    if not found[w]:
        if dist[u] + adj[u][w] < dist[w]:   ----> 최단 경로가 확정되지 않은 정점들 중에 u를 거쳐가는 경로의 거리가 더 짧으면
            dist[w] = dist[u] + adj[u][w]   ----> 그 값으로 dist를 갱신
----------------------------------------------------------------------------------------------------
### Dijkstra 알고리즘 최단 경로 소스 일부 ( 빈 칸 채우기 )
    dist[w] = min(dist[w], dist[u]+weight[u][w])

    최단 경로 값 dist[w] = min(기존에 있던 거리, u를 거쳐서 정점까지 가는 거리)
    여기서 기존에 있던 dist값이 더 작으면 그대로, 거쳐서 가는 거리가 더 작으면 dist갱신
----------------------------------------------------------------------------------------------------
    