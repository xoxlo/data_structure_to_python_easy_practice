# CHAPTER 7 정렬과 탐색

    비교할 수 있는 모든 속성들은 정렬의 기준이 될 수 있음
    오름차순, 내림차순 존재
    레코드 : 여러 개의 필드로 구성, 정렬 키
    정렬 : 레코드들을 키의 순서로 재배열하는 것
    내부정렬 : 모든 데이터가 메인 메모리에 올라와 있음
    외부정렬 : 외부 기억 장치에 대부분의 데이터가 있고, 일부 데이터만 메모리에 올려 정렬하는 방법 -> 대용량 자료 정렬하기 위해 사용
----------------------------------------------------------------------------------------------------
## 예상문제 ?

### 단순하고 비효율적인 정렬 방법과 복잡하고 효율적인 정렬 방법을 쓰시오.
    단순, 비효율적인 방법의 정렬은 삽입, 선택, 버블정렬이 있다.
    복잡, 효율적인 방법의 정렬은 퀵, 힙, 병합, 기수정렬이 있다.
----------------------------------------------------------------------------------------------------
### 안정성의 특징과 안정성에 따른 정렬을 쓰시오.
    안정성 : 입력 데이터에 동일한 킷값을 갖는 레코드가 여러 개 존재할 경우, 정렬 후에도 상대적 위치가 바뀌지 않는 것
    삽입, 버블, 병합정렬
----------------------------------------------------------------------------------------------------
### 맵과 딕셔너리의 차이점을 쓰시오.
    맵은 키의 중복이 허용되지않고 딕셔너리는 키의 중복이 허용된다.
----------------------------------------------------------------------------------------------------
### 맵을 구현하는 방법을 쓰시오.
    엔트리들을 리스트에 저장
    이진탐색트리 이용
    해싱 ( 맵 구현에 있어서 가장 좋은 방법 )
----------------------------------------------------------------------------------------------------
### 순차탐색과 이진탐색의 특징과 차이점을 쓰시오.
    순차탐색은 하나씩 비교해서 원하는 데이터를 찾는 방법이다.
    이진탐색은 배열의 중앙값을 기준으로 왼쪽, 오른쪽으로 구간을 나누어서 범위 줄여 나가면서 탐색하는 방법
    순차탐색은 시간복잡도가 O(n)이다.
    이진탐색은 시간복잡도가 O(log2n)이다,
    순차탐색은 간단하고 구현하기 쉬움, 하지만 효율적이지 않음
    이진탐색은 매우 효율적인 탐색 방법이지만 삽입, 삭제가 빈번한 응용에는 적합하지 않음, 그리고 반드시 정렬되어 있어야함
----------------------------------------------------------------------------------------------------
### 해싱의 특징을 쓰시오.
    시간복잡도가 O(n)
    삽입과 탐색은 탐색키를 인덱스로 생각하고 그 위치에 저장 or 읽기
    적절한 해싱 함수 구해야함 -> 대부분 h(k) = k mod M ( 여기서 M은 버킷 사이즈 )
    딕셔너리 타입을 사용
    해싱 충돌의 문제 발생 ( 주소의 중복 ) -> key가 다른데 주소값이 똑같은 경우
----------------------------------------------------------------------------------------------------
### 좋은 해시 함수의 조건을 쓰시오.
    충돌이 적어야함
    주소가 테이블에서 고르게 분포
    계산이 빨라야함
----------------------------------------------------------------------------------------------------
### 가장 일반적인 방법의 해시함수를 쓰시오.
    h(k) = k mod M
    코드로 쓰면 k % M
----------------------------------------------------------------------------------------------------
### 이상적인 해싱은 무엇인가?
    충돌이 일어나지 않는 해싱
    크기를 충분히 키운다
----------------------------------------------------------------------------------------------------
### 해싱에서 오버플로의 특징과 해결방법을 쓰시오.
    더 이상 저장할 수 없는, 넘쳐나는 현상이다.
    개방주소법과 체이닝이 있다.
    개방주소법은 다른 주소에 저장하는 방법인데 선형 조사법, 이차 조사법, 이중 해싱법이 있다.
    체이닝은 테이블의 구조를 변경하는 방법인데 연결리스트를 사용, 하나의 위치에 여러 개의 항목을 저장한다.
----------------------------------------------------------------------------------------------------
### 군집화 현상을 쓰시오
    한번 충돌이 발생한 위치에서 항목들이 집중되는 현상이다.
----------------------------------------------------------------------------------------------------
### 선형 조사법의 특징을 쓰시오.
    선형 조사법은 키의 레코드를 찾거나, 레코드가 없는 버킷을 만나거나 모든 버킷을 다 검사
----------------------------------------------------------------------------------------------------    
### 이차 조사법의 방법을 쓰시오.
    조사 되는 위치가 (h(k)+i*i)%M 으로 이동이 된다. ( 기존은 (i+1) % M )
    i^2 처럼 2차식?으로 이루어져 있어서 이차 조사법인듯
----------------------------------------------------------------------------------------------------
### 이중 해싱법의 특징을 쓰시오.
    다른 별개의 해시 함수를 이용
----------------------------------------------------------------------------------------------------
### 이진탐색과 이진탐색트리의 차이점
    이진탐색은 효율적이지만 레코드의 삽입, 삭제 처리가 복잡하다.
    이진탐색트리는 시간복잡도는 같지만 삽입, 삭제가 효율적이다.
## 탐색과 맵 구조
    테이블에서 원하는 탐색키를 가진 레코드를 찾는 작업
    맵(map) or 딕셔너리(dictionary)
    맵은 키의 중복 허용 X
    딕셔너리는 키의 중복 허용 O
    엔트리 : 키와 쌍으로 이루어짐. 키(key) -> 영어 단어와 같은 레코드를 구분할 수 있는 탐색키. 값(value) -> 단어의 의미와 같이 탐새기와 관련된 값
    맵을 구현하는 방법들 -> 엔트리들을 리스트에 저장하는 것, 이진탐색트리 이용, 맵을 구현하는 가장 좋은 방법은 '해싱'
----------------------------------------------------------------------------------------------------
## 순차탐색 (sequential search)
    가장 간단하고 직접적인 탐색 방법
    데이터가 담겨있는 리스트를 앞에서부터 하나씩 비교해서 원하는 데이터를 찾는 방법
----------------------------------------------------------------------------------------------------
## 이진탐색 (binary search)
    배열의 중앙에 있는 값을 조사하여 찾고자 하는 항목이 왼쪽 또는 오른쪽 부분 배열에 있는지 알아내어 탐색의 범위를 반으로 줄여가며 탐색 진행
----------------------------------------------------------------------------------------------------
## 보간탐색
    탐색키가 존재 할 위치를 예측하여 탐색
    리스트를 불균등하게 분할하여 탐색
----------------------------------------------------------------------------------------------------
## 고급 탐색 구조 : 해싱
    해싱 : 키 값을 해시 함수라는 수식에 대입시켜 계산한 후 나온 결과를 주소로 사용하여 바로 값에 접근하게 하는 방법
    자료의 삽입과 탐색은 탐색키를 인덱스로 생각하고 그 위치에 저장 or 읽기
    해시 함수 : 키 값을 값이 저장되는 주소 값으로 바꾸기 위한 수식
    해시 테이블 : 해시 함수에 의해 계산된 위치에 레코드를 저장한 테이블
    장점 : 단 한번의 접근으로 찾을 수 있음
    단점 : 해싱 충돌의 문제 발생 (주소의 중복). 서로 다른 키가 해시 함수에 의해 같은 주소로 계산되는 상황
----------------------------------------------------------------------------------------------------    
### 버킷과 슬롯
    해시 테이블은 M개의 버킷으로 구성
    하나의 버킷은 S개의 슬롯을 가짐
    하나의 슬롯에는 하나의 레코드가 저장
----------------------------------------------------------------------------------------------------
# 좋은 해시 함수 조건
    충돌이 적어야함
    함수 값이 테이블의 주소 영역 내에서 고르게 분포
    계산이 빨라야함
----------------------------------------------------------------------------------------------------
# 가장 일반적인 방법의 해시 함수
    h(k) = k mod M (키(key)를 버킷 사이즈로 나눔)
    가능하면 버킷 사이즈는 소수(prime number)로 선택
    비트 추출 방법 : M = 2^k일 때 탐색키를 이진수로 간주. 해시 주소의 집중 현상이 일어날 가능성이 많음
----------------------------------------------------------------------------------------------------
# 해싱의 오버플로 해결 방법
    개방 주소법(open adressing) -> 해시 테이블의 다른 위치(주소)에 저장
        - 선형 조사법, 이차 조사법 : 충돌이 발생하면 해시 함수 값에 1 또는 i^2을 더함
        - 이중 해싱법 : 해시 함수 값이 같더라도 탐색키다 다르면 서로 다른 순서를 갖게됨
    체이닝(chaining) -> 하나의 위치에 여러 개의 항목을 저장
        - 연결 리스트로 구현 가능
----------------------------------------------------------------------------------------------------
# 해시 함수 종류
    이동 폴딩 함수
    경계 폴딩 함수
    중간 제곱 함수
    비트 추출 방법
    숫자 분석 방법
    탐색키가 문자열
----------------------------------------------------------------------------------------------------
# 해싱 탐색 방법들의 성능 비교
    적재 밀도 or 적재 비율
    a = 저장된 항목의 개수/해시테이블의 버킷의 개수 = n/M
----------------------------------------------------------------------------------------------------