# CHAPTER 7 정렬과 탐색

    비교할 수 있는 모든 속성들은 정렬의 기준이 될 수 있음
    오름차순, 내림차순 존재
    레코드 : 여러 개의 필드로 구성, 정렬 키
    정렬 : 레코드들을 키의 순서로 재배열하는 것
    내부정렬 : 모든 데이터가 메인 메모리에 올라와 있음
    외부정렬 : 외부 기억 장치에 대부분의 데이터가 있고, 일부 데이터만 메모리에 올려 정렬하는 방법 -> 대용량 자료 정렬하기 위해 사용
----------------------------------------------------------------------------------------------------
# 예상문제 ?

## 단순하고 비효율적인 정렬 방법과 복잡하고 효율적인 정렬 방법을 쓰시오
    단순, 비효율적인 방법의 정렬은 삽입, 선택, 버블정렬이 있다.
    복잡, 효율적인 방법의 정렬은 퀵, 힙, 병합, 기수정렬이 있다.
----------------------------------------------------------------------------------------------------
## 안정성의 특징과 안정성에 따른 정렬을 쓰시오.
    안정성 : 입력 데이터에 동일한 킷값을 갖는 레코드가 여러 개 존재할 경우, 정렬 후에도 상대적 위치가 바뀌지 않는 것
    삽입, 버블, 병합정렬
----------------------------------------------------------------------------------------------------
## 탐색과 맵 구조
    테이블에서 원하는 탐색키를 가진 레코드를 찾는 작업
    맵(map) or 딕셔너리(dictionary)
    맵은 키의 중복 허용 X
    딕셔너리는 키의 중복 허용 O
    엔트리 : 키와 쌍으로 이루어짐. 키(key) -> 영어 단어와 같은 레코드를 구분할 수 있는 탐색키. 값(value) -> 단어의 의미와 같이 탐새기와 관련된 값
    맵을 구현하는 방법들 -> 엔트리들을 리스트에 저장하는 것, 이진탐색트리 이용, 맵을 구현하는 가장 좋은 방법은 '해싱'
----------------------------------------------------------------------------------------------------
## 순차탐색 (sequential search)
    가장 간단하고 직접적인 탐색 방법
    데이터가 담겨있는 리스트를 앞에서부터 하나씩 비교해서 원하는 데이터를 찾는 방법
----------------------------------------------------------------------------------------------------
## 이진탐색 (binary search)
    배열의 중앙에 있는 값을 조사하여 찾고자 하는 항목이 왼쪽 또는 오른쪽 부분 배열에 있는지 알아내어 탐색의 범위를 반으로 줄여가며 탐색 진행
----------------------------------------------------------------------------------------------------
## 보간탐색
    탐색키가 존재 할 위치를 예측하여 탐색
    리스트를 불균등하게 분할하여 탐색
----------------------------------------------------------------------------------------------------
## 고급 탐색 구조 : 해싱
    해싱 : 키 값을 해시 함수라는 수식에 대입시켜 계산한 후 나온 결과를 주소로 사용하여 바로 값에 접근하게 하는 방법
    자료의 삽입과 탐색은 탐색키를 인덱스로 생각하고 그 위치에 저장 or 읽기
    해시 함수 : 키 값을 값이 저장되는 주소 값으로 바꾸기 위한 수식
    해시 테이블 : 해시 함수에 의해 계산된 위치에 레코드를 저장한 테이블
    장점 : 단 한번의 접근으로 찾을 수 있음
    단점 : 해싱 충돌의 문제 발생 (주소의 중복). 서로 다른 키가 해시 함수에 의해 같은 주소로 계산되는 상황
----------------------------------------------------------------------------------------------------    
### 버킷과 슬롯
    해시 테이블은 M개의 버킷으로 구성
    하나의 버킷은 S개의 슬롯을 가짐
    하나의 슬롯에는 하나의 레코드가 저장
----------------------------------------------------------------------------------------------------
# 좋은 해시 함수 조건
    충돌이 적어야함
    함수 값이 테이블의 주소 영역 내에서 고르게 분포
    계산이 빨라야함
----------------------------------------------------------------------------------------------------
# 가장 일반적인 방법의 해시 함수
    h(k) = k mod M (키(key)를 버킷 사이즈로 나눔)
    가능하면 버킷 사이즈는 소수(prime number)로 선택
    비트 추출 방법 : M = 2^k일 때 탐색키를 이진수로 간주. 해시 주소의 집중 현상이 일어날 가능성이 많음
----------------------------------------------------------------------------------------------------
# 해싱의 오버플로 해결 방법
    개방 주소법(open adressing) -> 해시 테이블의 다른 위치(주소)에 저장
        - 선형 조사법, 이차 조사법 : 충돌이 발생하면 해시 함수 값에 1 또는 i^2을 더함
        - 이중 해싱법 : 해시 함수 값이 같더라도 탐색키다 다르면 서로 다른 순서를 갖게됨
    체이닝(chaining) -> 하나의 위치에 여러 개의 항목을 저장
        - 연결 리스트로 구현 가능
----------------------------------------------------------------------------------------------------
# 해시 함수 종류
    이동 폴딩 함수
    경계 폴딩 함수
    중간 제곱 함수
    비트 추출 방법
    숫자 분석 방법
    탐색키가 문자열
----------------------------------------------------------------------------------------------------
# 해싱 탐색 방법들의 성능 비교
    적재 밀도 or 적재 비율
    a = 저장된 항목의 개수/해시테이블의 버킷의 개수 = n/M
----------------------------------------------------------------------------------------------------